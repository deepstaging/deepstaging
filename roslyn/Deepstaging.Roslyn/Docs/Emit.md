# Emit

Fluent builders for generating compilable C# code. Symmetric with the query API - where queries find code, emit builders create it.

## Overview

Emit builders let you construct Roslyn syntax trees using a fluent, immutable API:

- **TypeBuilder** - Create classes, interfaces, structs, records
- **MethodBuilder** - Create methods
- **PropertyBuilder** - Create properties
- **FieldBuilder** - Create fields
- **ConstructorBuilder** - Create constructors
- **ParameterBuilder** - Create parameters
- **BodyBuilder** - Create method/property bodies
- **XmlDocumentationBuilder** - Create XML doc comments

All builders are immutable - each method returns a new instance.

## TypeBuilder

Create type declarations.

```csharp
var result = TypeBuilder
    .Class("Customer")
    .InNamespace("MyApp.Domain")
    .AsPartial()
    .AddProperty("Id", "Guid", p => p
        .WithAccessibility(Accessibility.Public)
        .WithAutoPropertyAccessors())
    .AddProperty("Name", "string", p => p
        .WithAccessibility(Accessibility.Public)
        .WithAutoPropertyAccessors())
    .Emit();

if (result.IsValid(out var valid))
{
    string code = valid.Code;
    CompilationUnitSyntax syntax = valid.Syntax;
}
```

### Factory Methods

| Method | Description |
|--------|-------------|
| `Class(string name)` | Create a class type |
| `Interface(string name)` | Create an interface type |
| `Struct(string name)` | Create a struct type |
| `Record(string name)` | Create a record type |

### Namespace & Usings

```csharp
TypeBuilder
    .Class("MyClass")
    .InNamespace("MyApp.Domain")
    .AddUsing("System")
    .AddUsing("System.Collections.Generic")
```

### Accessibility & Modifiers

```csharp
TypeBuilder
    .Class("MyClass")
    .WithAccessibility(Accessibility.Public)  // public, internal, private
    .AsStatic()    // static class
    .AsAbstract()  // abstract class
    .AsSealed()    // sealed class
    .AsPartial()   // partial class
```

### Interfaces

```csharp
TypeBuilder
    .Class("Repository")
    .Implements("IRepository")
    .Implements("IDisposable", "IAsyncDisposable")
```

### Adding Members

```csharp
// Add property with configuration
builder.AddProperty("Name", "string", prop => prop
    .WithAccessibility(Accessibility.Public)
    .WithAutoPropertyAccessors())

// Add pre-configured property
builder.AddProperty(PropertyBuilder.For("Name", "string").WithAutoPropertyAccessors())

// Add field
builder.AddField("_name", "string", field => field
    .WithAccessibility(Accessibility.Private)
    .AsReadOnly())

// Add method
builder.AddMethod("GetName", method => method
    .WithReturnType("string")
    .WithBody(body => body.Return("_name")))

// Add constructor
builder.AddConstructor(ctor => ctor
    .AddParameter("name", "string")
    .WithBody(body => body.Statement("_name = name;")))
```

### XML Documentation

```csharp
builder.WithXmlDoc("Represents a customer entity.")

// Or with more control
builder.WithXmlDoc(doc => doc
    .Summary("Represents a customer entity.")
    .Remarks("This class is generated by the source generator."))
```

### Emit

```csharp
// Emit with default options (syntax validation)
OptionalEmit result = builder.Emit();

// Emit with custom options
OptionalEmit result = builder.Emit(EmitOptions.Default
    .WithValidation(ValidationLevel.Syntax)
    .WithIndentation("    ")
    .WithEndOfLine("\n"));

// Check result
if (result.IsValid(out var valid))
{
    string code = valid.Code;                    // Formatted C# code
    CompilationUnitSyntax syntax = valid.Syntax; // Roslyn syntax tree
}
else
{
    ImmutableArray<Diagnostic> errors = result.Diagnostics;
}
```

---

## MethodBuilder

Create method declarations.

```csharp
MethodBuilder.For("ProcessOrder")
    .WithReturnType("Task<OrderResult>")
    .WithAccessibility(Accessibility.Public)
    .Async()
    .AddParameter("order", "Order")
    .AddParameter("token", "CancellationToken", p => p.WithDefault("default"))
    .WithBody(body => body
        .Statement("var result = await _processor.Process(order, token);")
        .Return("result"))
```

### Return Type

```csharp
method.WithReturnType("void")
method.WithReturnType("string")
method.WithReturnType("Task<int>")
method.WithReturnType("IAsyncEnumerable<Order>")
```

### Modifiers

```csharp
method.WithAccessibility(Accessibility.Public)
method.AsStatic()
method.AsVirtual()
method.AsOverride()
method.AsAbstract()
method.Async()
```

### Parameters

```csharp
// Simple parameter
method.AddParameter("name", "string")

// Parameter with configuration
method.AddParameter("count", "int", p => p
    .WithDefault("0"))

// Pre-configured parameter
method.AddParameter(ParameterBuilder.For("items", "IEnumerable<T>"))
```

### Body

```csharp
method.WithBody(body => body
    .Statement("Console.WriteLine(\"Starting\");")
    .Statement("DoWork();")
    .Return("result"))
```

---

## PropertyBuilder

Create property declarations.

```csharp
// Auto-property
PropertyBuilder.For("Name", "string")
    .WithAccessibility(Accessibility.Public)
    .WithAutoPropertyAccessors()

// Read-only auto-property
PropertyBuilder.For("Id", "Guid")
    .WithAccessibility(Accessibility.Public)
    .WithAutoPropertyAccessors()
    .AsReadOnly()

// Expression-bodied property
PropertyBuilder.For("FullName", "string")
    .WithAccessibility(Accessibility.Public)
    .WithGetter("$\"{FirstName} {LastName}\"")

// With initializer
PropertyBuilder.For("Items", "List<string>")
    .WithAutoPropertyAccessors()
    .WithInitializer("new()")
```

### Accessor Styles

```csharp
// Auto { get; set; }
prop.WithAutoPropertyAccessors()

// Read-only { get; }
prop.WithAutoPropertyAccessors().AsReadOnly()

// Expression-bodied => expression
prop.WithGetter("_name")
prop.WithGetter("=> _name")  // "=>" is optional

// Block-bodied getter
prop.WithGetter(body => body
    .Statement("if (_name == null) _name = LoadName();")
    .Return("_name"))

// Block-bodied setter
prop.WithSetter(body => body
    .Statement("_name = value;")
    .Statement("OnPropertyChanged();"))
```

### Modifiers

```csharp
prop.WithAccessibility(Accessibility.Public)
prop.AsStatic()
prop.AsVirtual()
prop.AsOverride()
prop.AsAbstract()
```

### Initialization

```csharp
prop.WithInitializer("new()")
prop.WithInitializer("default")
prop.WithInitializer("\"Default Value\"")
prop.WithBackingField("_name")  // Note: add field separately
```

---

## FieldBuilder

Create field declarations.

```csharp
FieldBuilder.For("_name", "string")
    .WithAccessibility(Accessibility.Private)
    .AsReadOnly()
    .WithInitializer("string.Empty")
```

### Modifiers

```csharp
field.WithAccessibility(Accessibility.Private)
field.AsStatic()
field.AsReadOnly()
field.AsConst()
field.AsVolatile()
```

---

## ConstructorBuilder

Create constructor declarations.

```csharp
ConstructorBuilder.For("Customer")
    .WithAccessibility(Accessibility.Public)
    .AddParameter("name", "string")
    .AddParameter("email", "string")
    .WithBody(body => body
        .Statement("Name = name;")
        .Statement("Email = email;"))
```

### Base/This Calls

```csharp
// Call base constructor
ctor.CallsBase("name", "email")

// Call another constructor
ctor.CallsThis("name")
```

---

## ParameterBuilder

Create parameter declarations.

```csharp
ParameterBuilder.For("name", "string")
    .WithDefault("\"Unknown\"")

ParameterBuilder.For("count", "int")
    .WithDefault("0")

ParameterBuilder.For("items", "IEnumerable<T>")
    .AsParams()
```

### Modifiers

```csharp
param.WithDefault("defaultValue")
param.AsRef()
param.AsOut()
param.AsIn()
param.AsParams()
```

---

## BodyBuilder

Build method and property bodies.

```csharp
BodyBuilder.Empty()
    .Statement("var x = 10;")
    .Statement("var y = 20;")
    .Return("x + y")
```

### Statements

```csharp
body.Statement("Console.WriteLine(\"Hello\");")
body.Statements(
    "var a = 1;",
    "var b = 2;",
    "var c = a + b;")
body.Return("result")
body.Return()  // void return
```

---

## XmlDocumentationBuilder

Create XML documentation comments.

```csharp
XmlDocumentationBuilder.Create()
    .Summary("Gets the customer name.")
    .Param("id", "The customer identifier.")
    .Returns("The customer name if found; otherwise, null.")
    .Remarks("This method queries the database.")
    .Example("<code>var name = GetName(123);</code>")
```

### Shorthand

```csharp
// Just a summary
XmlDocumentationBuilder.WithSummary("Gets the customer name.")

// On builders
builder.WithXmlDoc("Gets the customer name.")
builder.WithXmlDoc(doc => doc
    .Summary("Gets the customer name.")
    .Param("id", "The customer identifier."))
```

---

## EmitOptions

Configure code emission.

```csharp
EmitOptions.Default
    .WithValidation(ValidationLevel.Syntax)     // None, Syntax, Semantic, Full
    .WithIndentation("    ")                    // Indentation string
    .WithEndOfLine("\n")                        // Line ending
    .WithFullFormatter(false)                   // Use Roslyn formatter (slower)
```

---

## OptionalEmit

The result of emitting code.

```csharp
var result = builder.Emit();

// Check if valid
if (result.IsValid(out var valid))
{
    string code = valid.Code;
    CompilationUnitSyntax syntax = valid.Syntax;
}

// Check if invalid
if (result.IsNotValid(out var diagnostics))
{
    foreach (var diagnostic in diagnostics)
    {
        Console.WriteLine(diagnostic.GetMessage());
    }
}

// Get diagnostics (warnings even if valid)
ImmutableArray<Diagnostic> diags = result.Diagnostics;
```

---

## Complete Example

```csharp
var result = TypeBuilder
    .Class("CustomerRepository")
    .InNamespace("MyApp.Data")
    .AddUsing("System")
    .AddUsing("System.Threading.Tasks")
    .Implements("ICustomerRepository")
    .WithXmlDoc("Repository for customer data access.")
    .AddField("_context", "DbContext", f => f
        .WithAccessibility(Accessibility.Private)
        .AsReadOnly())
    .AddConstructor(ctor => ctor
        .WithAccessibility(Accessibility.Public)
        .AddParameter("context", "DbContext")
        .WithBody(body => body.Statement("_context = context;")))
    .AddMethod("GetByIdAsync", m => m
        .WithReturnType("Task<Customer?>")
        .WithAccessibility(Accessibility.Public)
        .Async()
        .AddParameter("id", "Guid")
        .AddParameter("cancellationToken", "CancellationToken", p => p.WithDefault("default"))
        .WithXmlDoc(doc => doc
            .Summary("Gets a customer by identifier.")
            .Param("id", "The customer identifier.")
            .Param("cancellationToken", "Cancellation token.")
            .Returns("The customer if found; otherwise, null."))
        .WithBody(body => body
            .Return("await _context.Customers.FindAsync(new object[] { id }, cancellationToken)")))
    .Emit();

if (result.IsValid(out var valid))
{
    // Add to source generation context
    context.AddSource("CustomerRepository.g.cs", valid.Code);
}
```
