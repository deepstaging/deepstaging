# Deepstaging.Roslyn.Generators

Template infrastructure for building Roslyn source generators with Scriban.

## What is this?

A focused library that makes Scriban template-based code generation seamless in Roslyn generators:

- **Template resolution** — Load embedded Scriban templates from your generator assembly  
- **Smart caching** — Template text and parsed templates cached for IDE responsiveness
- **Context extensions** — `AddFromTemplate()` methods for both initialization and production contexts
- **Error handling** — Template errors converted to diagnostics automatically
- **Hint name generation** — Consistent file naming for generated code

Works with any incremental source generator. Pairs naturally with `Deepstaging.Roslyn` for symbol queries and code emission.

## Quick Start

### 1. Add a template to your generator project

Create `Templates/Runtime.scriban-cs`:

```scriban
// <auto-generated/>
#nullable enable

namespace {{ Namespace }};

{{ Accessibility }} sealed partial class {{ ClassName }}
{
    public {{ ClassName }}(
{{~ for dep in Dependencies ~}}
        {{ dep.FullyQualifiedName }} {{ dep.ParameterName }}{{ if !for.last }},{{ end }}
{{~ end ~}}
    )
    {
{{~ for dep in Dependencies ~}}
        {{ dep.PropertyName }} = {{ dep.ParameterName }};
{{~ end ~}}
    }

{{~ for dep in Dependencies ~}}
    public {{ dep.FullyQualifiedName }} {{ dep.PropertyName }} { get; }
{{~ end ~}}
}
```

Mark as embedded resource in `.csproj`:

```xml
<ItemGroup>
  <EmbeddedResource Include="Templates\*.scriban-cs" />
</ItemGroup>
```

### 2. Use in your generator

```csharp
using Deepstaging.Roslyn.Generators;

[Generator]
public sealed class MyGenerator : IIncrementalGenerator
{
    // Create template name factory once
    private static readonly Func<string, TemplateName> Named = 
        TemplateName.ForGenerator<MyGenerator>();
    
    private static readonly HintNameProvider Hints = new("MyGenerator");
        
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var pipeline = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "MyNamespace.MyAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => BuildModel(ctx));

        context.RegisterSourceOutput(pipeline, static (ctx, model) =>
        {
            ctx.AddFromTemplate(
                Named("Runtime.scriban-cs"),
                Hints.Filename(model.ClassName),
                model);
        });
    }
}
```

Templates are automatically loaded, cached, and rendered with error handling.

## Core API

### `TemplateName`

Identifies templates by name and assembly. Create a factory function once:

```csharp
private static readonly Func<string, TemplateName> Named = 
    TemplateName.ForGenerator<MyGenerator>();

var template = Named("MyTemplate.scriban-cs");
```

Template names resolve to: `{GeneratorNamespace}.Templates.{TemplateName}`

### `AddFromTemplate()` Extensions

Extensions for `SourceProductionContext` and `IncrementalGeneratorPostInitializationContext`:

```csharp
// Production context (with optional diagnostics)
context.AddFromTemplate(
    Named("MyClass.scriban-cs"),
    "MyClass.g.cs",
    model,
    diagnostics: validationErrors,  // Optional - skips generation if present
    format: true);                  // Optional - formats using Roslyn

// Post-initialization context (for static code)
context.AddFromTemplate(
    Named("GlobalUsings.scriban-cs"),
    "GlobalUsings.g.cs",
    format: true);
```

### `Template.RenderTemplate()`

Low-level rendering when you need direct control:

```csharp
var result = Template.RenderTemplate(Named("MyTemplate.scriban-cs"), model);

switch (result)
{
    case RenderResult.Success s:
        var code = s.Text;
        break;
    case RenderResult.Failure f:
        context.ReportDiagnostic(f.Diagnostic);
        break;
}
```

### `HintNameProvider`

Consistent hint name generation:

```csharp
var hints = new HintNameProvider("MyGenerator");

// "MyGenerator/MyClass.g.cs"
var hint1 = hints.Filename("MyClass");

// "MyGenerator.Attributes/MyAttribute.g.cs"
var hint2 = hints.Filename("Attributes", "MyAttribute");
```

## Features

### Smart Caching

Templates are cached at two levels:

1. **Template text** — Embedded resources loaded once per (Assembly, ResourceName)
2. **Parsed templates** — Scriban parsing cached by template text (~5-10ms saved per render)

Critical for IDE responsiveness during development.

### Error Handling

Template errors become Roslyn diagnostics:

- Parse errors → `TemplateRenderError` diagnostic with location
- Runtime errors → Exception details in diagnostic message
- Displayed in IDE error list with template name

### Formatting Support

Optional Roslyn-based formatting normalizes generated code:

```csharp
context.AddFromTemplate(
    template,
    hintName,
    model,
    format: true);  // Formats using CSharpSyntaxTree normalization
```

## Template Conventions

### File Organization

```
MyGenerator/
├── MyGenerator.cs
├── Discovery/
│   └── RuntimeDiscovery.cs
├── Emitters/
│   └── RuntimeEmitter.cs
└── Templates/
    ├── Runtime.scriban-cs
    └── RuntimeDI.scriban-cs
```

### Naming

Use `.scriban-cs` extension for C# templates. The `-cs` suffix helps IDEs recognize it as C# content for syntax highlighting.

### Embedding

```xml
<ItemGroup>
  <EmbeddedResource Include="Templates\*.scriban-cs" />
</ItemGroup>
```

## Complete Example

This example uses `Deepstaging.Roslyn` for symbol queries and `Deepstaging.Roslyn.Generators` for templating:

```csharp
using Deepstaging.Roslyn;
using Deepstaging.Roslyn.Generators;

[Generator]
public sealed class RuntimeGenerator : IIncrementalGenerator
{
    private static readonly Func<string, TemplateName> Named = 
        TemplateName.ForGenerator<RuntimeGenerator>();
    
    private static readonly HintNameProvider Hints = new("Runtime");

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var runtimes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "MyApp.RuntimeAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => BuildModel(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(runtimes, static (ctx, model) =>
        {
            ctx.AddFromTemplate(
                Named("Runtime.scriban-cs"),
                Hints.Filename(model!.ClassName),
                model);
        });
    }

    private static RuntimeModel? BuildModel(GeneratorAttributeSyntaxContext ctx)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol type)
            return null;

        // Use Deepstaging.Roslyn queries to extract properties
        var properties = PropertyQuery.From(type)
            .ThatArePublic()
            .ThatAreReadOnly()
            .GetAll();

        return new RuntimeModel
        {
            Namespace = type.ContainingNamespace.ToDisplayString(),
            ClassName = type.Name,
            Accessibility = type.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Dependencies = properties
                .Select(p => new DependencyModel
                {
                    FullyQualifiedName = p.Type.ToDisplayString(),
                    PropertyName = p.Name,
                    ParameterName = char.ToLowerInvariant(p.Name[0]) + p.Name[1..]
                })
                .ToArray()
        };
    }
}

public record RuntimeModel
{
    public string Namespace { get; init; } = "";
    public string ClassName { get; init; } = "";
    public string Accessibility { get; init; } = "public";
    public DependencyModel[] Dependencies { get; init; } = [];
}

public record DependencyModel
{
    public string FullyQualifiedName { get; init; } = "";
    public string PropertyName { get; init; } = "";
    public string ParameterName { get; init; } = "";
}
```

Template (`Templates/Runtime.scriban-cs`):

```scriban
// <auto-generated/>
#nullable enable

namespace {{ Namespace }};

{{ Accessibility }} sealed partial class {{ ClassName }}
{
    public {{ ClassName }}(
{{~ for dep in Dependencies ~}}
        {{ dep.FullyQualifiedName }} {{ dep.ParameterName }}{{ if !for.last }},{{ end }}
{{~ end ~}}
    )
    {
{{~ for dep in Dependencies ~}}
        {{ dep.PropertyName }} = {{ dep.ParameterName }};
{{~ end ~}}
    }

{{~ for dep in Dependencies ~}}
    public {{ dep.FullyQualifiedName }} {{ dep.PropertyName }} { get; }
{{~ end ~}}
}
```

## Dependencies

- **Microsoft.CodeAnalysis.CSharp** — Roslyn APIs (formatting)
- **Scriban** — Template engine (private asset)

## See Also

- **[Deepstaging.Roslyn](../Deepstaging.Roslyn/)** — Query builders and emit API for Roslyn
- **[Scriban Documentation](https://github.com/scriban/scriban/tree/master/doc)** — Template syntax reference
- **[Source Generators Cookbook](https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md)** — Roslyn generator patterns
