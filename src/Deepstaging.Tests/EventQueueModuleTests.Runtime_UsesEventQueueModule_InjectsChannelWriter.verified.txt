// <auto-generated/>
#nullable enable

namespace TestApp;

/// <summary>
/// Capability interface for DomainEvents queue.
/// Implement this interface on your runtime to publish events to the DomainEvents queue.
/// </summary>
public interface IHasDomainEventsQueue
{
    /// <summary>
    /// Gets the channel writer for publishing IDomainEvent events.
    /// </summary>
    global::System.Threading.Channels.ChannelWriter<global::TestApp.IDomainEvent> DomainEventsWriter { get; }
}


// <auto-generated/>
#nullable enable

using LanguageExt;
using LanguageExt.Effects;
using static LanguageExt.Prelude;

namespace TestApp;

/// <summary>
/// Effect methods for publishing to the DomainEvents queue.
/// </summary>
public static partial class DomainEventsQueueEffects
{
    /// <summary>
    /// Publishes an event to the DomainEvents queue.
    /// </summary>
    /// <param name="evt">The event to publish.</param>
    /// <returns>An effect that publishes the event.</returns>
    public static Eff<RT, Unit> Publish<RT>(global::TestApp.IDomainEvent evt) where RT : IHasDomainEventsQueue =>
        liftEff<RT, Unit>(async rt =>
        {
            await rt.DomainEventsWriter.WriteAsync(evt);
            return unit;
        });

    /// <summary>
    /// Publishes an event to the DomainEvents queue with a cancellation token.
    /// </summary>
    /// <param name="evt">The event to publish.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>An effect that publishes the event.</returns>
    public static Eff<RT, Unit> Publish<RT>(global::TestApp.IDomainEvent evt, System.Threading.CancellationToken cancellationToken) where RT : IHasDomainEventsQueue =>
        liftEff<RT, Unit>(async rt =>
        {
            await rt.DomainEventsWriter.WriteAsync(evt, cancellationToken);
            return unit;
        });

    /// <summary>
    /// Tries to publish an event to the DomainEvents queue synchronously.
    /// </summary>
    /// <param name="evt">The event to publish.</param>
    /// <returns>An effect that returns true if the event was published.</returns>
    public static Eff<RT, bool> TryPublish<RT>(global::TestApp.IDomainEvent evt) where RT : IHasDomainEventsQueue =>
        liftEff<RT, bool>(rt => rt.DomainEventsWriter.TryWrite(evt));
}


// <auto-generated/>
#nullable enable

using System.Threading;
using System.Threading.Channels;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace TestApp;

/// <summary>
/// BackgroundService that processes events from the DomainEvents queue.
/// </summary>
public sealed class DomainEventsQueueService : BackgroundService
{
    private readonly ChannelReader<global::TestApp.IDomainEvent> _reader;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<DomainEventsQueueService> _logger;

    /// <summary>
    /// Creates a new DomainEventsQueueService.
    /// </summary>
    public DomainEventsQueueService(
        ChannelReader<global::TestApp.IDomainEvent> reader,
        IServiceProvider serviceProvider,
        ILogger<DomainEventsQueueService> logger)
    {
        _reader = reader;
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("DomainEvents queue service started");
        
        // Process events sequentially
        await foreach (var evt in _reader.ReadAllAsync(stoppingToken))
        {
            await ProcessEventAsync(evt, stoppingToken);
        }
        
        _logger.LogInformation("DomainEvents queue service stopped");
    }

    private async Task ProcessEventAsync(global::TestApp.IDomainEvent evt, CancellationToken cancellationToken)
    {
        try
        {
            _logger.LogDebug("Processing {EventType} from DomainEvents queue", evt.GetType().Name);
            
            // No handlers registered for this queue
            _logger.LogWarning("No handlers configured for DomainEvents queue");
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing {EventType} from DomainEvents queue", evt.GetType().Name);
        }
    }
}


// <auto-generated/>
#nullable enable

namespace TestApp;

public sealed partial class AppRuntime : IHasDomainEventsQueue
{
    /// <summary>
    /// Creates a new instance of AppRuntime with all dependencies.
    /// </summary>
    public AppRuntime(
        global::System.Threading.Channels.ChannelWriter<global::TestApp.IDomainEvent> domainEventsWriter
    )
    {
        DomainEventsWriter = domainEventsWriter;
        OnInitialized();
    }

    /// <summary>
    /// Gets the ChannelWriter&lt;IDomainEvent&gt; dependency.
    /// </summary>
    public global::System.Threading.Channels.ChannelWriter<global::TestApp.IDomainEvent> DomainEventsWriter { get; }

    /// <summary>
    /// Called after construction. Override in partial class for initialization logic.
    /// </summary>
    partial void OnInitialized();
}


// <auto-generated/>
#nullable enable

using Microsoft.Extensions.DependencyInjection;

namespace TestApp;

/// <summary>
/// Extension methods for registering AppRuntime with dependency injection.
/// </summary>
public static class AppRuntimeExtensions
{
    /// <summary>
    /// Registers AppRuntime and all its dependencies with the service collection.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddAppRuntime(this IServiceCollection services)
    {
        // Register the runtime
        services.AddScoped<AppRuntime>();
        
        return services;
    }
}
